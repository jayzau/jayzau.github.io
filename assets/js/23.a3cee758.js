(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{375:function(e,v,_){"use strict";_.r(v);var o=_(42),t=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("个人吐槽.一切问题的源头可能都因为自己太菜.")]),e._v(" "),_("h2",{attrs:{id:"model相关"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#model相关"}},[e._v("#")]),e._v(" Model相关")]),e._v(" "),_("ol",[_("li",[_("strong",[_("code",[e._v("DB")]),e._v("方式查询和"),_("code",[e._v("Model(Eloquent ORM)")]),e._v("方式查询返回数据类型不一致")])])]),e._v(" "),_("p",[e._v("都是官方工具类,并且"),_("code",[e._v("Model")]),e._v("查询方法兼容"),_("code",[e._v("DB")]),e._v("查询方法("),_("a",{attrs:{href:"https://learnku.com/docs/laravel/8.x/queries/9401",target:"_blank",rel:"noopener noreferrer"}},[e._v("查询构造器"),_("OutboundLink")],1),e._v("),\n那么按道理查询结果返回的数据格式应该一致.但是!"),_("code",[e._v("DB")]),e._v("的"),_("code",[e._v("toArray()")]),e._v("方法返回的数据中,只能将最外层转换为数组,其内部还是"),_("code",[e._v("stdClass")]),e._v("对象.而"),_("code",[e._v("Model")]),e._v("的"),_("code",[e._v("toArray()")]),e._v("全部转换为数组.\n最初学习的时候为了方便,全部使用的"),_("code",[e._v("DB")]),e._v("方式查询,后来更换为"),_("code",[e._v("Model")]),e._v("方式后,代码从"),_("code",[e._v("Controller")]),e._v("改到"),_("code",[e._v("View")]),e._v("...")]),e._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[e._v("IDE支持不友好")])])]),e._v(" "),_("p",[e._v("其实也还好,就是"),_("code",[e._v("DB")]),e._v("改为"),_("code",[e._v("Model")]),e._v("后,PHPStorm代码提示报黄了,一度认为是我写法不对,但是官方文档也这样写啊...后来查了帖子,两种解决方案.")]),e._v(" "),_("p",[e._v("第一种,装一个插件,"),_("a",{attrs:{href:"https://github.com/barryvdh/laravel-ide-helper",target:"_blank",rel:"noopener noreferrer"}},[e._v("laravel-ide-helper"),_("OutboundLink")],1),e._v(",好像很麻烦,还得改项目配置.")]),e._v(" "),_("p",[e._v("第二种,查询时加一个"),_("code",[e._v("query()")]),e._v(",后面再跟常规查询语句."),_("code",[e._v("Model::query()->where()...")]),e._v(".挺喜欢这种写法的.")]),e._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("strong",[e._v("服务太周到了")]),e._v("(这也是错?)")])]),e._v(" "),_("p",[e._v("其实个人觉得"),_("code",[e._v("laravel")]),e._v("的模型层很棒,使用很方便.但是不明白为什么它要主动去维护一些东西.比如:")]),e._v(" "),_("blockquote",[_("p",[e._v("Eloquent 也会假设每个数据表都有一个名为 "),_("code",[e._v("id")]),e._v(" 的主键列。你可以定义一个受保护的 "),_("code",[e._v("$primaryKey")]),e._v(" 属性来重写约定。")]),e._v(" "),_("p",[e._v("默认情况下，Eloquent 预期你的数据表中存在 "),_("code",[e._v("created_at")]),e._v(" 和 "),_("code",[e._v("updated_at")]),e._v(" 两个字段 。如果你不想让 Eloquent 自动管理这两个列， 请将模型中的 "),_("code",[e._v("$timestamps")]),e._v(" 属性设置为 false")]),e._v(" "),_("p",[e._v("...")])]),e._v(" "),_("p",[e._v("这些东西难道不应该是"),_("code",[e._v("laravel")]),e._v("可以主动提供,但是否使用由用户来决定吗?对于这点,还是更喜欢"),_("code",[e._v("Flask")]),e._v("的理念.")]),e._v(" "),_("p",[e._v("**!!!**201029")]),e._v(" "),_("p",[e._v("才发现,"),_("code",[e._v("insert")]),e._v("方法不会主动维护相关时间戳字段,哪怕是用的"),_("code",[e._v("Eloquent模型")]),e._v("来写.原因呢?网上一帖子说是因为原生语法("),_("code",[e._v("DB")]),e._v("内置查询方法?)都不支持自动维护.")]),e._v(" "),_("p",[e._v("问同事,都是自己主动写时间戳...说明对于官方提供的这个功能并不满意.也没找到具体哪些方法能用哪些方法不能用.看来只能自个儿试?")])])}),[],!1,null,null,null);v.default=t.exports}}]);