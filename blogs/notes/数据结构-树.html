<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构:树 | Jayzau</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="好劲!">
    
    <link rel="preload" href="/assets/css/0.styles.c0542458.css" as="style"><link rel="preload" href="/assets/js/app.c5305ee3.js" as="script"><link rel="preload" href="/assets/js/2.2733607c.js" as="script"><link rel="preload" href="/assets/js/29.ac371324.js" as="script"><link rel="prefetch" href="/assets/js/10.ef8e919d.js"><link rel="prefetch" href="/assets/js/11.8ec9eea4.js"><link rel="prefetch" href="/assets/js/12.d902eacd.js"><link rel="prefetch" href="/assets/js/13.aec05fab.js"><link rel="prefetch" href="/assets/js/14.2805f5ea.js"><link rel="prefetch" href="/assets/js/15.8a264712.js"><link rel="prefetch" href="/assets/js/16.3b4138e0.js"><link rel="prefetch" href="/assets/js/17.eec3c406.js"><link rel="prefetch" href="/assets/js/18.25d28f03.js"><link rel="prefetch" href="/assets/js/19.090949aa.js"><link rel="prefetch" href="/assets/js/20.43c0a74c.js"><link rel="prefetch" href="/assets/js/21.f60ea17e.js"><link rel="prefetch" href="/assets/js/22.022efc2e.js"><link rel="prefetch" href="/assets/js/23.a3cee758.js"><link rel="prefetch" href="/assets/js/24.dfaf9b90.js"><link rel="prefetch" href="/assets/js/25.4bb80798.js"><link rel="prefetch" href="/assets/js/26.7dc791f1.js"><link rel="prefetch" href="/assets/js/27.b87628ec.js"><link rel="prefetch" href="/assets/js/28.b44871cc.js"><link rel="prefetch" href="/assets/js/3.2241a300.js"><link rel="prefetch" href="/assets/js/30.c10170f6.js"><link rel="prefetch" href="/assets/js/31.ab3d6217.js"><link rel="prefetch" href="/assets/js/32.1e3fbc5c.js"><link rel="prefetch" href="/assets/js/33.13439f83.js"><link rel="prefetch" href="/assets/js/34.ee9bff09.js"><link rel="prefetch" href="/assets/js/35.b9fbcc7f.js"><link rel="prefetch" href="/assets/js/36.9293bf0b.js"><link rel="prefetch" href="/assets/js/37.71f16844.js"><link rel="prefetch" href="/assets/js/38.2c1388e6.js"><link rel="prefetch" href="/assets/js/4.5a3a6bf8.js"><link rel="prefetch" href="/assets/js/5.aad4954c.js"><link rel="prefetch" href="/assets/js/6.20be021d.js"><link rel="prefetch" href="/assets/js/7.5a1615ac.js"><link rel="prefetch" href="/assets/js/8.4f988748.js"><link rel="prefetch" href="/assets/js/9.e5f1a567.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c0542458.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Jayzau</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客" class="mobile-dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/notes/" class="nav-link router-link-active">
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/blogs/python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/blogs/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/php/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/blogs/go/" class="nav-link">
  Go
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/jayzau" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客" class="mobile-dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/notes/" class="nav-link router-link-active">
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/blogs/python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/blogs/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/php/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/blogs/go/" class="nav-link">
  Go
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/jayzau" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据结构:树</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#什么是树" class="sidebar-link">什么是树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#如何实现有效率的查找" class="sidebar-link">如何实现有效率的查找？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#引子-顺序查找和二分查找。" class="sidebar-link">引子：顺序查找和二分查找。</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#树的表示" class="sidebar-link">树的表示</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#树的一些基本术语" class="sidebar-link">树的一些基本术语</a></li><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#儿子-兄弟表示法" class="sidebar-link">儿子-兄弟表示法</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#二叉树的定义" class="sidebar-link">二叉树的定义</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#特殊二叉树" class="sidebar-link">特殊二叉树</a></li><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#二叉树几个重要性质" class="sidebar-link">二叉树几个重要性质</a></li><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【code】二叉树的抽象数据类型定义" class="sidebar-link">【code】二叉树的抽象数据类型定义</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#二叉树的储存结构" class="sidebar-link">二叉树的储存结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【code】二叉树的遍历" class="sidebar-link">【code】二叉树的遍历</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#二叉搜索树" class="sidebar-link">二叉搜索树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【code】二叉搜索树操作的特别函数" class="sidebar-link">【code】二叉搜索树操作的特别函数</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#平衡二叉树" class="sidebar-link">平衡二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#平衡二叉树的调整" class="sidebar-link">平衡二叉树的调整</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#堆" class="sidebar-link">堆</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【例】优先队列" class="sidebar-link">【例】优先队列</a></li><li class="sidebar-sub-header"><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【code】堆的抽象数据类型描述" class="sidebar-link">【code】堆的抽象数据类型描述</a></li></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【视频课程】哈夫曼树-集合及运算" class="sidebar-link">【视频课程】哈夫曼树/集合及运算</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blogs/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html#【待补充】红黑树-b树" class="sidebar-link">【待补充】红黑树/B树...</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构-树"><a href="#数据结构-树" class="header-anchor">#</a> 数据结构:树</h1> <h2 id="什么是树"><a href="#什么是树" class="header-anchor">#</a> 什么是树</h2> <blockquote><p>树是一种数据结构，它是由n(n&gt;=1)个有限结点组成一个具有层次关系的集合。</p></blockquote> <p>图例：</p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="Linux目录结构"></p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E4%BA%BA%E7%B1%BB%E6%97%8F%E8%B0%B1.jpg" alt="人类族谱"></p> <blockquote><p>分层次组织在管理上具有更高的效率。</p></blockquote> <h2 id="如何实现有效率的查找"><a href="#如何实现有效率的查找" class="header-anchor">#</a> 如何实现有效率的查找？</h2> <p><strong>查找：<strong>根据某个给定</strong>关键字K</strong>，从<strong>集合R</strong>中找出与<strong>K</strong>相同的记录。</p> <ul><li><p><strong>静态查找：<strong>集合中</strong>记录是固定</strong>的。</p> <ul><li>没有插入和删除的操作，只有查找。</li></ul></li> <li><p><strong>动态查找：<strong>集合中</strong>记录是动态变化</strong>的。</p> <ul><li>除了查找，还可能发生插入和删除。</li></ul></li></ul> <h3 id="引子-顺序查找和二分查找。"><a href="#引子-顺序查找和二分查找。" class="header-anchor">#</a> 引子：顺序查找和二分查找。</h3> <ul><li>顺序查找：略。时间复杂度为 O(n)</li> <li><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener noreferrer">二分查找<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：时间复杂度为 O(logN)</li></ul> <p>假设待查找的元素队列为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</p> <p>二分查找的顺序为：[6, 3, 1, 2] / [6, 3, 4, 5] / [6, 9, 7, 8] / [6, 9, 10, 11]</p> <p>以上4种查找方案能查找出所有元素，最大查找次数为4次。用树的形式来展示：</p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91.jpg" alt="二分查找判定树"></p> <h2 id="树的表示"><a href="#树的表示" class="header-anchor">#</a> 树的表示</h2> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="树的表示"></p> <h3 id="树的一些基本术语"><a href="#树的一些基本术语" class="header-anchor">#</a> 树的一些基本术语</h3> <ol><li>结点的度（Degree）：结点的<strong>子树个数</strong></li> <li>树的度：树的所有结点中最大的度数</li> <li>叶结点（Leaf）：<strong>度为0</strong>的结点</li> <li>父节点（Parent）：有子树的结点就是其子树的父节点。例如：A是B的父节点（树1）。</li> <li>子节点（Child）：例如：B是A的子节点（树1）。</li> <li>兄弟结点（Sibling）：具有同一父节点的节点彼此是兄弟结点。例如：B的兄弟结点是C和D。</li> <li>路径和路径长度：例如：A-&gt;K的路径，路径长度为3。</li> <li>祖先结点（Ancestor）：沿<strong>树根到某节点路径上的所有结点</strong>都是该结点的祖先结点。</li> <li>子孙结点（Descendant）：某结点的<strong>子树中所有结点</strong>都是该结点的子孙结点。</li> <li>结点的层次（Level）：规定<strong>根节点在1层</strong>，其他任意一结点的层数是其父节点的层数加1。</li> <li>树的深度（Depth）：树中所有结点中的<strong>最大层次</strong>就是这棵树的深度。</li></ol> <h3 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="header-anchor">#</a> 儿子-兄弟表示法</h3> <p>由上图树2可以看出，每个结点的形式并不相同。结点的子节点数有0至3个不等，这对程序访问并不友好。如果将所有结点的子节点树统一为3（树的所有节点中最大的子节点树）个，则会造成空间浪费。儿子-兄弟表示法可以完美的解决这个问题。</p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E5%84%BF%E5%AD%90-%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="儿子-兄弟表示法"></p> <p>如上图，处理后旋转一下角度不难看出形成了一颗<strong>二叉树</strong>。</p> <h2 id="二叉树的定义"><a href="#二叉树的定义" class="header-anchor">#</a> 二叉树的定义</h2> <blockquote><p><strong>二叉树（T）：<strong>一个有穷的结点集合。这个集合</strong>可以为空</strong>，若不为空，则它是由<strong>根结点</strong>和称为其**左子树T<sub>L</sub><strong>和</strong>右子树T<sub>R</sub>**的两个不相交的二叉树组成。</p></blockquote> <ul><li>二叉树具有五种基本形态：
<ul><li>Φ</li> <li>T</li> <li>T, T<sub>L</sub></li> <li>T, T<sub>R</sub></li> <li>T, T<sub>L</sub>, T<sub>R</sub></li></ul></li> <li>二叉树的<strong>子树有左右顺序之分</strong>(T<sub>L</sub>/T<sub>R</sub>)</li></ul> <h3 id="特殊二叉树"><a href="#特殊二叉树" class="header-anchor">#</a> 特殊二叉树</h3> <ul><li>斜二叉树(Skewed Binary Tree)[skjuːd ˈbaɪnəri triː]：一边歪的二叉树。/  \</li> <li>满二叉树(Full Binary Tree)：一棵深度为<strong>k</strong>且有<strong>2<sup>k</sup>-1</strong>个结点的二叉树称为满二叉树。</li> <li>完美二叉树(Perfect Binary Tree)：同满二叉树。</li> <li>完全二叉树(Complete Binary Tree)：有<strong>n</strong>个节点的二叉树，对树中的节点按从上到下、从左到右的顺序进行编号，编号为<strong>i(1&lt;=i&lt;=n)<strong>的结点与满二叉树中编号为</strong>i</strong>的结点在二叉树中位置相同。
<ul><li>满二叉树由下到上、由右到左依次删除结点，每次删除结点后的二叉树就可以叫做完全二叉树。</li></ul></li></ul> <h3 id="二叉树几个重要性质"><a href="#二叉树几个重要性质" class="header-anchor">#</a> 二叉树几个重要性质</h3> <ul><li>一个二叉树第<strong>i</strong>层的最大结点数为：<strong>2<sup>i-1</sup>, i&gt;=1</strong>。</li> <li>深度为<strong>k</strong>的二叉树有最大结点总数为：<strong>2<sup>k-1</sup>, k&gt;=1</strong>。</li> <li>对任何非空二叉树<strong>T</strong>，若**n<sub>0</sub>**表示叶节点的个数、<strong>n<sub>2</sub><strong>是度为</strong>2</strong>的非叶结点个数，那么两者满足关系 <strong>n<sub>0</sub> = n<sub>2</sub> + 1</strong>。</li></ul> <h3 id="【code】二叉树的抽象数据类型定义"><a href="#【code】二叉树的抽象数据类型定义" class="header-anchor">#</a> 【code】二叉树的抽象数据类型定义</h3> <ul><li>类型名称：<strong>二叉树</strong></li> <li>数据对象集：一个有穷的结点集合。若不为空，则由<strong>根结点和其左右二叉子树</strong>组成。</li> <li>操作集：<strong>BT∈BinTree</strong>, <strong>Item∈ElementType</strong>，重要操作有：
<ul><li><code>def IsEmpty(BT: BinTree) -&gt; bool:</code>：判别BT是否为空；</li> <li><code>def Traversal(BT: BinTree):</code>：遍历，按某顺序访问每个结点；</li> <li><code>def CreatBinTree() -&gt; BinTree:</code>：创建一个二叉树。</li></ul></li></ul> <hr> <p><strong>常用遍历方法：</strong></p> <ul><li><code>def PreOrderTraversal(BT: BinTree):</code>：先序 =&gt; 根、左子树、右子树；</li> <li><code>def InOrderTraversal(BT: BinTree):</code>：中序 =&gt; 左子树、根、右子树；</li> <li><code>def PostOrderTraversal(BT: BinTree):</code>：后序 =&gt; 左子树、右子树、根；</li> <li><code>def LevelOrderTraversal(BT: BinTree):</code>：层次遍历 =&gt; 从上到下、从左到右；</li></ul> <h2 id="二叉树的储存结构"><a href="#二叉树的储存结构" class="header-anchor">#</a> 二叉树的储存结构</h2> <ol><li><p>顺序储存结构</p> <ul><li><p><strong>完全二叉树：<strong>按从上至下、从左到右顺序储存</strong>n</strong>个节点的完全二叉树的<strong>结点父子关系</strong>。</p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98.jpg" alt="完全二叉树顺序储存"></p></li> <li><p>**一般二叉树：**一般二叉树也可以采用上方结构，但会造成空间浪费。</p> <p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98.jpg" alt="一般二叉树顺序储存"></p></li></ul></li> <li><p>链表存储</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    Data <span class="token operator">=</span> <span class="token boolean">None</span>
    Left<span class="token punctuation">:</span> BinTree
    Right<span class="token punctuation">:</span> Bintree
</code></pre></div><p><img src="/images/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/%E9%93%BE%E8%A1%A8%E5%82%A8%E5%AD%98.jpg" alt="链表储存"></p></li></ol> <h2 id="【code】二叉树的遍历"><a href="#【code】二叉树的遍历" class="header-anchor">#</a> 【code】二叉树的遍历</h2> <ol><li><p><strong>先序遍历</strong></p> <p>遍历过程：</p> <ol><li>访问<strong>根结点</strong></li> <li><strong>先序</strong>遍历其<strong>左子树</strong></li> <li><strong>先序</strong>遍历其<strong>右子树</strong></li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">PreOrderTravelsal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> BT<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;</span><span class="token interpolation"><span class="token punctuation">{</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>				<span class="token comment"># 输出当前值</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>		<span class="token comment"># 访问左结点</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>		<span class="token comment"># 访问右结点</span>
</code></pre></div></li> <li><p><strong>中序遍历</strong></p> <p>遍历过程：</p> <ol><li><strong>中序</strong>遍历其<strong>左子树</strong></li> <li>访问根结点</li> <li><strong>中序</strong>遍历其<strong>右子树</strong></li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">InOrderTravelsal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> BT<span class="token punctuation">:</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>		<span class="token comment"># 访问左结点</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;</span><span class="token interpolation"><span class="token punctuation">{</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>				<span class="token comment"># 输出当前值</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>		<span class="token comment"># 访问右结点</span>
</code></pre></div></li> <li><p><strong>后序遍历</strong></p> <p>遍历过程：</p> <ol><li><strong>后序</strong>遍历其<strong>左子树</strong></li> <li><strong>后序</strong>遍历其<strong>右子树</strong></li> <li>访问<strong>根结点</strong></li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">PostOrderTravelsal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> BT<span class="token punctuation">:</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>		<span class="token comment"># 访问左结点</span>
        PreOrderTraversal<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>		<span class="token comment"># 访问右结点</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;</span><span class="token interpolation"><span class="token punctuation">{</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>				<span class="token comment"># 输出当前值</span>
</code></pre></div></li></ol> <p>先序、中序和后序遍历过程中经过结点的<strong>路线一样</strong>（绕着树从左往右画了一圈轮廓），只是<strong>访问各节点的时机不同</strong>。</p> <ol start="4"><li><p><strong>非递归遍历（先序、中序、后序）</strong></p> <p>利用堆栈，后进后出来实现。</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">PreOrderTravelsal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
	stack<span class="token punctuation">:</span> Stack <span class="token operator">=</span> CreatStack<span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span>
    <span class="token keyword">while</span> BT <span class="token keyword">or</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> BT<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>			<span class="token comment"># 访问后压栈</span>
            Push<span class="token punctuation">(</span>stack<span class="token punctuation">,</span> BT<span class="token punctuation">)</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>left
        <span class="token keyword">if</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            BT <span class="token operator">=</span> Pop<span class="token punctuation">(</span>stack<span class="token punctuation">)</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>right

        
<span class="token keyword">def</span> <span class="token function">InOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    stack<span class="token punctuation">:</span> Stack <span class="token operator">=</span> CreatStack<span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span>
    <span class="token keyword">while</span> BT <span class="token keyword">or</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> BT<span class="token punctuation">:</span>					<span class="token comment"># 只要有左节点，就压栈</span>
            Push<span class="token punctuation">(</span>stack<span class="token punctuation">,</span> BT<span class="token punctuation">)</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>Left
        <span class="token keyword">if</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            BT <span class="token operator">=</span> Pop<span class="token punctuation">(</span>stack<span class="token punctuation">)</span>			<span class="token comment"># 栈不为空，弹出栈顶结点</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>			<span class="token comment"># 访问结点</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>Right			<span class="token comment"># 转向右子树</span>
            
            
<span class="token keyword">def</span> <span class="token function">PostOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    stack<span class="token punctuation">:</span> Stack <span class="token operator">=</span> CreatStack<span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span>
    stack2<span class="token punctuation">:</span> Stack <span class="token operator">=</span> CreatStack<span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span>
    <span class="token keyword">while</span> BT <span class="token keyword">or</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> BT<span class="token punctuation">:</span>					<span class="token comment"># ...</span>
            Push<span class="token punctuation">(</span>stack<span class="token punctuation">,</span> BT<span class="token punctuation">)</span>
            Push<span class="token punctuation">(</span>stack<span class="token punctuation">,</span> BT2<span class="token punctuation">)</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>Right
        <span class="token keyword">if</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            BT <span class="token operator">=</span> Pop<span class="token punctuation">(</span>stack<span class="token punctuation">)</span>
            BT <span class="token operator">=</span> BT<span class="token punctuation">.</span>Left
    <span class="token keyword">while</span> <span class="token keyword">not</span> IsEmpty<span class="token punctuation">(</span>stack2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        BT <span class="token operator">=</span> Pop<span class="token punctuation">(</span>stack2<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>层序遍历</strong></p> <p>二叉树遍历的核心问题：<strong>二维结构的线性化</strong></p> <p><strong>队列实现</strong>：遍历从根结点开始，首先将<strong>根结点</strong>入队，然后执行循环：结点出队、访问该结点、其左右儿子入队。</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">LevelOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> BT<span class="token punctuation">:</span>
		Q <span class="token operator">=</span> CreatQueue<span class="token punctuation">(</span>MaxSize<span class="token punctuation">)</span>
        Add<span class="token punctuation">(</span>Q<span class="token punctuation">,</span> BT<span class="token punctuation">)</span>					<span class="token comment"># 根结点先入队</span>
        <span class="token keyword">while</span> <span class="token keyword">not</span> IsEmptyQ<span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            BT <span class="token operator">=</span> DeleteQ<span class="token punctuation">(</span>Q<span class="token punctuation">)</span>			<span class="token comment"># 队列中取出元素</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>			<span class="token comment"># 访问</span>
            <span class="token keyword">if</span> BT<span class="token punctuation">.</span>Left<span class="token punctuation">:</span>
                AddQ<span class="token punctuation">(</span>Q<span class="token punctuation">,</span> BT<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>	<span class="token comment"># 左孩子入队</span>
            <span class="token keyword">if</span> BT<span class="token punctuation">.</span>Right<span class="token punctuation">:</span>
                AddQ<span class="token punctuation">(</span>Q<span class="token punctuation">,</span> BT<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>	<span class="token comment"># 右孩子入队</span>
</code></pre></div></li></ol> <p><strong>【例】求二叉树的高度</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">PostOrderGetHeight</span><span class="token punctuation">(</span>BT<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> BT<span class="token punctuation">:</span>
        HL <span class="token operator">=</span> PostOrderGetHeight<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>
        HR <span class="token operator">=</span> PostOrderGetHeight<span class="token punctuation">(</span>BT<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>
        MaxH <span class="token operator">=</span> HL <span class="token keyword">if</span> HL <span class="token operator">&gt;</span> HR <span class="token keyword">else</span> HR
        <span class="token keyword">return</span> MaxH
    <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre></div><p><strong>【例】由两种遍历序列确定二叉树</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 必须要有中序遍历和其余任意一种遍历才能确定一颗二叉树</span>
</code></pre></div><h2 id="二叉搜索树"><a href="#二叉搜索树" class="header-anchor">#</a> 二叉搜索树</h2> <blockquote><p><strong>二叉搜索树(BST, Binary Search Tree)</strong>，也称<strong>二叉排序树或二叉查找树</strong>。</p> <p>可以为空，如果不为空，满足以下性质：</p> <ul><li>非空<strong>左子树</strong>的所有<strong>键值小于其根结点</strong>的键值。</li> <li>非空<strong>右子树</strong>的所有<strong>键值大于其根结点</strong>的键值。</li> <li><strong>左、右子树都是二叉搜索树。</strong></li></ul> <p><strong>对二叉搜索树（查找树）进行中序遍历可得到从小到大的序列。</strong></p></blockquote> <h3 id="【code】二叉搜索树操作的特别函数"><a href="#【code】二叉搜索树操作的特别函数" class="header-anchor">#</a> 【code】二叉搜索树操作的特别函数</h3> <ul><li><code>def Find(X, BST: BinTree) -&gt; Position:</code>：从二叉搜索树BST中查找元素X，返回其所在的结点的地址。</li> <li><code>def FindMin(BST: BinTree) -&gt; Position:</code>：从二叉搜索树BST中查找并返回最小元素所在结点的地址。</li> <li><code>def FindMax(BST: BinTree) -&gt; Position:</code>：从二叉搜索树BST中查找并返回最大元素所在节点的地址。</li> <li><code>def Insert(X, BST: BinTree) -&gt; BinTree:</code>：插入元素X到二叉搜索树BST。</li> <li><code>def Delete(X, BST: BinTree) -&gt; BinTree:</code>：从二叉搜索树BST删除元素X。</li></ul> <p><strong>二叉搜索树的查找：</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">Find</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Position<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> BST<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>						<span class="token comment"># 空树</span>
    <span class="token keyword">if</span> X <span class="token operator">&gt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
        <span class="token keyword">return</span> Find<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>		<span class="token comment"># 大于当前结点，在右子树中查找</span>
    <span class="token keyword">elif</span> X <span class="token operator">&lt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
        <span class="token keyword">return</span> Find<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>		<span class="token comment"># 小于当前结点，在左子树中查找</span>
    <span class="token keyword">return</span> BST


<span class="token keyword">def</span> <span class="token function">IterFind</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Position<span class="token punctuation">:</span>      <span class="token comment"># 迭代效率高于递归</span>
    <span class="token keyword">while</span> BST<span class="token punctuation">:</span>
        <span class="token keyword">if</span> X <span class="token operator">&gt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
            BST <span class="token operator">=</span> BST<span class="token punctuation">.</span>Right
        <span class="token keyword">elif</span> X <span class="token operator">&lt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
            BST <span class="token operator">=</span> BST<span class="token punctuation">.</span>Left
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> BST
    <span class="token keyword">return</span> <span class="token boolean">None</span>


<span class="token keyword">def</span> <span class="token function">FindMin</span><span class="token punctuation">(</span>BST<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Position<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> BST<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">if</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">:</span>                        <span class="token comment"># 最小元素一定在最左分支的端点上</span>
        <span class="token keyword">return</span> FindMin<span class="token punctuation">(</span>BST<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    FindMax: 最大元素一定在最右分支的端点上
    &quot;&quot;&quot;</span>
    <span class="token keyword">return</span> BST
</code></pre></div><p><strong>二叉搜索树的插入与删除</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">Insert</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> BinTree<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> BST<span class="token punctuation">:</span>                                 <span class="token comment"># 没有结点，就自己做结点生成一棵树</span>
        BST <span class="token operator">=</span> BinTree<span class="token punctuation">(</span><span class="token punctuation">)</span>
        BST<span class="token punctuation">.</span>Data <span class="token operator">=</span> X
        BST<span class="token punctuation">.</span>Left <span class="token operator">=</span> <span class="token boolean">None</span>
        BST<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> X <span class="token operator">&gt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
            BST<span class="token punctuation">.</span>Right <span class="token operator">=</span> Insert<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token comment"># 大于结点，往右子树插入</span>
        <span class="token keyword">elif</span> X <span class="token operator">&lt;</span> BST<span class="token punctuation">:</span>
            BST<span class="token punctuation">.</span>Left <span class="token operator">=</span> Insert<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>      <span class="token comment"># 小于结点，往左子树插入</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
    <span class="token keyword">return</span> BST


<span class="token keyword">def</span> <span class="token function">Delete</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">:</span> BinTree<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> BinTree<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> BST<span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">if</span> X <span class="token operator">&gt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
        BST<span class="token punctuation">.</span>Right <span class="token operator">=</span> Delete<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>        <span class="token comment"># 在右子树中删除</span>
    <span class="token keyword">elif</span> X <span class="token operator">&lt;</span> BST<span class="token punctuation">.</span>Data<span class="token punctuation">:</span>
        BST<span class="token punctuation">.</span>Left <span class="token operator">=</span> Delete<span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>          <span class="token comment"># 在左子树中删除</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> BST<span class="token punctuation">.</span>Left <span class="token keyword">and</span> BST<span class="token punctuation">.</span>Right<span class="token punctuation">:</span>
            <span class="token comment"># 左右子树都有，取左子树最大结点或者右子树最小结点来替代自身</span>
            <span class="token triple-quoted-string string">&quot;&quot;&quot;     删除 41
                30             30            30
               /  \           /  \          /  \ 
              15  41         15  35        15  35
                 /  \           /  \          /  \ 
                33  50   =&gt;    33  50  =&gt;    33  50
                  \              \            \ 
                  35             35           34
                 /              /
                34             34
            &quot;&quot;&quot;</span>
            MaxBst <span class="token operator">=</span> FindMax<span class="token punctuation">(</span>BST<span class="token punctuation">)</span>
            BST<span class="token punctuation">.</span>Data <span class="token operator">=</span> MinBst<span class="token punctuation">.</span>Data
            BST<span class="token punctuation">.</span>Left <span class="token operator">=</span> Delete<span class="token punctuation">(</span>BST<span class="token punctuation">.</span>Data<span class="token punctuation">,</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> BST<span class="token punctuation">.</span>Left<span class="token punctuation">:</span>
            <span class="token comment"># 只有左子树就用左子树替代自身</span>
            BST <span class="token operator">=</span> BST<span class="token punctuation">.</span>Left
        <span class="token keyword">elif</span> BST<span class="token punctuation">.</span>Right<span class="token punctuation">:</span>
            <span class="token comment"># 只有右子树就用右子树替代自身</span>
            BST <span class="token operator">=</span> BST<span class="token punctuation">.</span>Right
        <span class="token keyword">else</span><span class="token punctuation">:</span>                                   <span class="token comment"># 被删除的结点没有子结点</span>
            <span class="token comment"># 直接删除当前结点</span>
            BST <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">return</span> BST
</code></pre></div><h2 id="平衡二叉树"><a href="#平衡二叉树" class="header-anchor">#</a> 平衡二叉树</h2> <blockquote><p><strong>平衡因子(Balance Factor, 简称BF)</strong>：BF(T) = h<sub>L</sub> - h<sub>R</sub>，其中h<sub>L</sub>和h<sub>R</sub>分别为T的左右子树高度。</p> <p><strong>平衡二叉树(Balanced Binary Tree)(AVL树)</strong>：空树，或者任一结点左右子树的高度差的绝对值不超过1，即 |BF(T)| &lt;= 1。</p></blockquote> <h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="header-anchor">#</a> 平衡二叉树的调整</h3> <ul><li>LL旋转、LR旋转、RR旋转、RL旋转。</li></ul> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <blockquote><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p> <ul><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li> <li>堆总是一棵完全二叉树。</li></ul> <p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p></blockquote> <h3 id="【例】优先队列"><a href="#【例】优先队列" class="header-anchor">#</a> 【例】优先队列</h3> <p>特殊的“队列”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。</p> <h3 id="【code】堆的抽象数据类型描述"><a href="#【code】堆的抽象数据类型描述" class="header-anchor">#</a> 【code】堆的抽象数据类型描述</h3> <p><strong>最大堆：</strong> <strong>完全二叉树</strong>，每个结点的元素值<strong>不小于</strong>其子结点的元素值。最大堆H∈MaxHeap，元素Item∈ElementType，主要操作有：</p> <ul><li><code>def Create(MaxSize: int) -&gt; MaxHeap:</code>：创建一个空的最大堆。</li> <li><code>def IsFull(H: MaxHeap) -&gt; bool:</code>：判断最大堆H是否已满。</li> <li><code>def Insert(H: MaxHeap, item):</code>：将元素item插入最大堆H。</li> <li><code>def IsEmpty(H: MaxHeap) -&gt; bool:</code>：判断最大堆H是否为空。</li> <li><code>def DeleteMax(H: MaxHeap):</code>：返回H中最大的元素（高优先级）。</li></ul> <p><strong>最大堆的创建、插入、删除：</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">HeapStruct</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    Elements<span class="token punctuation">:</span> <span class="token builtin">iter</span>		<span class="token comment"># 储存堆元素的数组</span>
    Size<span class="token punctuation">:</span> <span class="token builtin">int</span>			<span class="token comment"># 堆的当前元素个数</span>
    Capacity<span class="token punctuation">:</span> <span class="token builtin">int</span>		<span class="token comment"># 堆的最大容量</span>
        

<span class="token keyword">class</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>HeapStruct<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
        
        
<span class="token keyword">def</span> <span class="token function">Create</span><span class="token punctuation">(</span>MaxSize<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    H<span class="token punctuation">:</span> MaxHeap <span class="token operator">=</span> MaxHeap<span class="token punctuation">(</span><span class="token punctuation">)</span>
    H<span class="token punctuation">.</span>Elements <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>MaxSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    H<span class="token punctuation">.</span>Size <span class="token operator">=</span> <span class="token number">0</span>
    H<span class="token punctuation">.</span>Capacity <span class="token operator">=</span> MaxSize
    H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> MaxData			<span class="token comment"># 哨兵 	 float('inf')	</span>
    <span class="token comment"># 最小堆-&gt;MinData 						    float('-inf')</span>
    <span class="token keyword">return</span> H


<span class="token keyword">def</span> <span class="token function">Insert</span><span class="token punctuation">(</span>H<span class="token punctuation">:</span> MaxHeap<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    将新增结点插入到从其父结点到根结点的有序序列中
    :param H: 最大堆
    :param item: 待插入的元素
    :return: 
    &quot;&quot;&quot;</span>
    <span class="token keyword">if</span> IsFull<span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;最大堆已满&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> 
    H<span class="token punctuation">.</span>Size <span class="token operator">+=</span> <span class="token number">1</span>
    i<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> H<span class="token punctuation">.</span>Size				<span class="token comment"># i指向插入后堆中最后一个元素的位置</span>
    <span class="token keyword">while</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> item<span class="token punctuation">:</span>	<span class="token comment"># 父节点小于当前元素，一定要有哨兵终止循环！</span>
        H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        i <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>			<span class="token comment"># 向下取整</span>
    H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item
    
    
<span class="token keyword">def</span> <span class="token function">DeleteMax</span><span class="token punctuation">(</span>H<span class="token punctuation">:</span> MaxHeap<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    取出根结点（最大值）元素，同时删除堆的一个结点
    :param H: 最大堆
    :return: 最大元素
    &quot;&quot;&quot;</span>
    <span class="token keyword">if</span> IsEmpty<span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;最大堆已空&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    MaxItem <span class="token operator">=</span> H<span class="token punctuation">.</span>Element<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>		<span class="token comment"># 最大值为根结点</span>
    temp <span class="token operator">=</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>H<span class="token punctuation">.</span>Size<span class="token punctuation">]</span>	<span class="token comment"># temp为最后一个元素</span>
    H<span class="token punctuation">.</span>Size <span class="token operator">-=</span> <span class="token number">1</span>					<span class="token comment"># 元素少1</span>
    Parent <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">while</span> Parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> H<span class="token punctuation">.</span>Size<span class="token punctuation">:</span>
        Child <span class="token operator">=</span> Parent <span class="token operator">*</span> <span class="token number">2</span>		<span class="token comment"># 左子元素下标</span>
        <span class="token keyword">if</span> Child <span class="token operator">!=</span> H<span class="token punctuation">.</span>Size <span class="token keyword">and</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            Child <span class="token operator">+=</span> <span class="token number">1</span>			<span class="token comment"># 左右子结点取最大</span>
        <span class="token keyword">if</span> temp <span class="token operator">&gt;=</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Child<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>					<span class="token comment"># 子元素填充到当前元素</span>
            H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Child<span class="token punctuation">]</span>
        Parent <span class="token operator">=</span> Child
    H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> temp
    <span class="token keyword">return</span> MaxItem
</code></pre></div><p><strong>最大堆的建立：<strong>将</strong>已经存在的N个元素</strong>按最大堆的要求存放在一个一维数组中。</p> <ul><li>方法1：通过插入操作，将N个元素<strong>一个个相继插入到一个初始为空的堆中去</strong>，其时间代价最大为<strong>O(N logN)</strong>。</li> <li>方法2：在<strong>线性时间复杂度</strong>下建立最大堆。<strong>O(N)</strong> <ol><li>将N的元素按输入顺序存入，先满足<strong>完全二叉树的结构特性</strong>。</li> <li>调整各节点位置，以满足最大堆的<strong>有序特性</strong>。</li></ol></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 方法1 略</span>
<span class="token comment"># 方法2 插入过程略，重点在于调整结点位置</span>
<span class="token keyword">def</span> <span class="token function">SortMaxHeap</span><span class="token punctuation">(</span>H<span class="token punctuation">:</span> HeapStruct<span class="token punctuation">)</span><span class="token punctuation">:</span>
    Parent <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>H<span class="token punctuation">.</span>Size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>		<span class="token comment"># 最后一个有子结点的结点</span>
    <span class="token keyword">while</span> Parent <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        Root <span class="token operator">=</span> Parent
        <span class="token keyword">while</span> Root <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> H<span class="token punctuation">.</span>Size<span class="token punctuation">:</span>
            Node <span class="token operator">=</span> Root <span class="token operator">*</span> <span class="token number">2</span>
            <span class="token keyword">if</span> Node <span class="token operator">!=</span> H<span class="token punctuation">.</span>Size <span class="token keyword">and</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Node<span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                Node <span class="token operator">+=</span> <span class="token number">1</span>			<span class="token comment"># 比较左右分支</span>
            <span class="token keyword">if</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Root<span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Node<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 父节点小于子结点，换位</span>
                H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Root<span class="token punctuation">]</span><span class="token punctuation">,</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Node<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Node<span class="token punctuation">]</span><span class="token punctuation">,</span> H<span class="token punctuation">.</span>Elements<span class="token punctuation">[</span>Root<span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>				<span class="token comment"># 父节点大于所有子结点，跳出</span>
            Root <span class="token operator">=</span> Node				<span class="token comment"># 继续往孙结点排查</span>
        Parent <span class="token operator">-=</span> <span class="token number">1</span>					<span class="token comment"># 直到根结点调整完成</span>
</code></pre></div><p>测试结果：</p> <table><thead><tr><th>Size(元素个数)</th> <th>方法1耗时(s)</th> <th>方法2耗时(s)</th></tr></thead> <tbody><tr><td>100,000</td> <td>0.09956479072570801</td> <td>0.04955148696899414</td></tr> <tr><td>1,000,000</td> <td>1.1037354469299316</td> <td>0.6593151092529297</td></tr> <tr><td>10,000,000</td> <td>11.347627401351929</td> <td>7.2457115650177</td></tr></tbody></table> <h2 id="【视频课程】哈夫曼树-集合及运算"><a href="#【视频课程】哈夫曼树-集合及运算" class="header-anchor">#</a> 【视频课程】哈夫曼树/集合及运算</h2> <p><a href="https://www.icourse163.org/course/ZJU-93001" target="_blank" rel="noopener noreferrer">数据结构(浙江大学)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="【待补充】红黑树-b树"><a href="#【待补充】红黑树-b树" class="header-anchor">#</a> 【待补充】红黑树/B树...</h2> <hr> <p>2021-02-01:快两个月没看相关的知识，今天碰到相关的题型发现全忘完了。。。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上一次编辑于:</span> <span class="time">2/1/2021, 2:22:23 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c5305ee3.js" defer></script><script src="/assets/js/2.2733607c.js" defer></script><script src="/assets/js/29.ac371324.js" defer></script>
  </body>
</html>
